The architecture of this frame data plugin will be as follows:


FramedataProvider: Node:    // node to edit with plugin, stores dictionary of frame data
                            with corresponding name.

FrameData: Resource         // resource to store framedata for a specific attack or 
                            section of attack

FrameDataFrame: Resource    // resource to store framedata for a specific frame in the
                            framedata, including what info?
                                    including information about all the hitboxes,
                                    information about where to move hurtbox

                                    //this does mean the data is highly coupled tho
                                    //between the specific character hurtbox and framedata
                                    //hurtbox should be included in the framedata? somehow
                                    //how do I do that?
                                    //probably using keyframes for the hurtbox

                                    //hurtbox changes could just be dispatched in sync with
                                    //hitboxes?

                                    //hurtbox can just be updated based on id (StringName)
                                    //of hurtbox part?
                                    //hurtbox(es) are also included in framedata, (based on)
                                    //using a model of moving a hurtbox shapes using joints?
                                    
                                    //hurtboxes can just be a seperate hitbox layer

// godot physics execution order:


// ->
// physics collision check (inaccessible)  
// ->
// emit collision signals 
// ->
// physics process

FunctionBoxShape2D: Shape2D
    variables:
        -- inherit all
        inherited shape must be Shape2D.

FunctionBox: Resource
    variables:
        data: Resource (some type of resource, cast this to the type expected for the)
             //functionbox layer
        key: byte (map this to StringName when you can bother)
        priority: int (precalculated (assert no equal priority))
    methods:
        push_to_shape(shape: FunctionBoxShape2D) -> void; 

FunctionBoxCircle: FunctionBox
    variables:
        position: Vector2 //relative position of box
        radius: float //radius of box
        interpolateFrom: FunctionBoxCircle //enforce only interpolate from FunctionBoxCircle from LAST FRAME
            //nullable
    methods:
        override push_to_shape(shape: FunctionBoxShape2D) -> void;

//compromise: DON'T FUCKING BOTHER INTERPOLATING THIS GARBAGE.
FunctionBoxCapsule: FunctionBox
    variables:
        positionA: Vector2 //relative position of box point a
        positionB: Vector2 //relative position of box point b
        radius: float //radius of points
    methods:
        override push_to_shape(shape: FunctionBoxShape2D) -> void;


during physics process

//framework key concepts:

    functionbox layer

        hitbox layer
        hurtbox layer
        intangible layer // not needed, could still help for debug tho-
        grabbox layer
        shieldbox layer?
        etc.

    a functionbox layer must have a area2d priority equal to it's priority for this
    to work because then we can make thing emit in order.

    a functionbox layer executes a function when a box on that layer intersects with
    another box

    layers should have a priority, in what order do they execute their functionality?

        how??
        this is a hard question...
        what the fuck do I do here???
        I mean I guess I could

    // signal order queuing
    // maybe I should queue up results from events -> execute on physics steps
    // by doing that, you can ensure that hitboxes execute hit events in order

    when observing an event, put event in list according to hitbox index and priority,
        
        // is this a bit too heavyweight? it only executes on events, could this
        // potentially cause a lagspike?
        index by entity -> index by key ->
                //reduce the entity -> key -> val 
                //maybe into (entity,key) -> val?
                //dictionary is required anyways...
                //entityindex: u23, key: u8?
                    //first bit is reserved since godot does not have unsigned...
                //global to create next handle for the entity index? if the thing ever
                //even gets to the u23

                //could leave this as an optional optimization...
                
                //worst case: provide workaround option to get keys using entity -> index
            // *** IMPORTANT: implement the optimized option above IF AND ONLY IF I
            // HAVE TIME TO.    

            //is it faster using index by key -> index by entity or
            //index by entity -> index by key?

            //section this off into a function definitely.

            is current collision priority in that index higher or lower than last collision?
                    // tradeoff to prevent potential bullshit with nested arrays: 

                    // any collision source functionbox has an id,
                    // if that ID is ignoring another source, drop this collision.

                    // if shieldbox hits a hitbox of an index, it entirely nullifies 
                    // all hitboxes of that index for that specific enemy without
                    // any checks, effectively parried
                    
                    // if collider priority is equal, check collided priority,
                    // if collided priority is greater, overwrite.

    queued up ->
        stored data:
            Intersected: FunctionBox //FunctionBox that is hit, this could be a 
                    //hurtbox intersected by a hitbox
                    //or a hitbox intersected by a shieldbox.

                    //access the source through this, check if should be dropped using updated
                    //ignored sources list.
            Intersecting: FunctionBox //highest priority functionbox in that index.
                    //only data attached to functionbox is technically needed, but
                    //I doubt there's much of a cost of including the actualy functionbox
            
        
            

    // can I control signal priority??
    // NO. NOT IN 4.5, NOT IN ANY 4.*
    //ideally, using seperate steps to process different priorities
    //the signal order is based on position in tree, impossible to control
    //unless you want to fuck up the scenetree


    for each function layer -> 
        for each queued up -> 
            if ignored -> // (again )(this may have changed due to previous layers)
                skip
            process hit (using layer process)
        
    shieldbox -> hitbox -> hurtbox(dummy layer)

    hitbox function layer -> checks hurtbox function layer, when overlaps with hurtbox,
                            add to ignore list and apply hit effect

                            when overlapping, executes

    hurtbox function layer -> dummy, does not do anything on it's own, but is controlled 
                            by framedata as well

    shieldbox function layer -> disables hitboxes that are hit by this layer, priority
                            over hitbox layer